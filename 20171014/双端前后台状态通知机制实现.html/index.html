<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>移动端前后台状态通知机制实现 | Tkooops</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="背景为了支持端上网络库内部组件获取App状态，以便使用合适的策略，例如如果当前App在后台，网络库便不再去主动解析DNS结果，这样可以节省对移动端设备的资源消耗。因此项目需要做一个移动端前后台状态判断及通知机制。由于我们支持iOS和Android，因此这个特性也分别针对双端做，上层用一个抽象类封装。 概要设计 初始化：网络库启动时，会初始化Notifier实例，但会根据不同的端实例化不同的子类。N">
<meta property="og:type" content="article">
<meta property="og:title" content="移动端前后台状态通知机制实现">
<meta property="og:url" content="http://kkrisen.top/20171014/双端前后台状态通知机制实现.html/index.html">
<meta property="og:site_name" content="Tkooops">
<meta property="og:description" content="背景为了支持端上网络库内部组件获取App状态，以便使用合适的策略，例如如果当前App在后台，网络库便不再去主动解析DNS结果，这样可以节省对移动端设备的资源消耗。因此项目需要做一个移动端前后台状态判断及通知机制。由于我们支持iOS和Android，因此这个特性也分别针对双端做，上层用一个抽象类封装。 概要设计 初始化：网络库启动时，会初始化Notifier实例，但会根据不同的端实例化不同的子类。N">
<meta property="og:image" content="http://kkrisen.top/20171014/双端前后台状态通知机制实现.html/new_front_back.png">
<meta property="og:image" content="http://kkrisen.top/20171014/双端前后台状态通知机制实现.html/new_front_back_thread.png">
<meta property="og:updated_time" content="2017-10-16T15:37:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="移动端前后台状态通知机制实现">
<meta name="twitter:description" content="背景为了支持端上网络库内部组件获取App状态，以便使用合适的策略，例如如果当前App在后台，网络库便不再去主动解析DNS结果，这样可以节省对移动端设备的资源消耗。因此项目需要做一个移动端前后台状态判断及通知机制。由于我们支持iOS和Android，因此这个特性也分别针对双端做，上层用一个抽象类封装。 概要设计 初始化：网络库启动时，会初始化Notifier实例，但会根据不同的端实例化不同的子类。N">
<meta name="twitter:image" content="http://kkrisen.top/20171014/双端前后台状态通知机制实现.html/new_front_back.png">
  
    <link rel="alternate" href="/atom.xml" title="Tkooops" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Tkooops</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">teakeeper</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://kkrisen.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-双端前后台状态通知机制实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/20171014/双端前后台状态通知机制实现.html/" class="article-date">
  <time datetime="2017-10-14T06:40:25.000Z" itemprop="datePublished">2017-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      移动端前后台状态通知机制实现
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3><span id="背景">背景</span></h3><p>为了支持端上网络库内部组件获取App状态，以便使用合适的策略，例如如果当前App在后台，网络库便不再去主动解析DNS结果，这样可以节省对移动端设备的资源消耗。<br>因此项目需要做一个移动端前后台状态判断及通知机制。由于我们支持iOS和Android，因此这个特性也分别针对双端做，上层用一个抽象类封装。</p>
<h3><span id="概要设计">概要设计</span></h3><ol>
<li>初始化：网络库启动时，会初始化Notifier实例，但会根据不同的端实例化不同的子类。Notifier用于探测当前App状态并通过回调方式通知下游用户。</li>
<li>用户注册：我们提供了标准的用户回调抽象类，下游用户通过继承并实现具体的抽象方法生成新的实例，并将该实例注册进Notifier。</li>
<li>在状态发生变更时，Notifier会轮询一遍所有等待回调的用户（第2步注册进来的）触发用户自定义动作。<a id="more"></a>
</li>
</ol>
<p>逻辑架构图<br><img src="/20171014/双端前后台状态通知机制实现.html/new_front_back.png" width="70%" height="70%"></p>
<p>运行架构图(以Android为例)<br><img src="/20171014/双端前后台状态通知机制实现.html/new_front_back_thread.png" alt="new_front_back_thread"></p>
<h3><span id="详细设计">详细设计</span></h3><p><strong>前后台状态分类</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> AppStatusType &#123;</div><div class="line">    APP_STATUS_UNKNOWN = <span class="number">0</span>,      <span class="comment">// Uncertain state </span></div><div class="line">    APP_STATUS_FOREGROUND = <span class="number">1</span>,   <span class="comment">// iOS(DidBecomeActive); Android(DidBecomeActive)</span></div><div class="line">    APP_STATUS_BACKGROUND = <span class="number">2</span>,   <span class="comment">// iOS(DidEnterBackgroun); Android(DidEnterBackgroun)</span></div><div class="line">    APP_STATUS_TERMINATING = <span class="number">3</span>,  <span class="comment">// iOS(WillTerminate); Android();</span></div><div class="line">    APP_STATUS_LAST = APP_STATUS_TERMINATING</div><div class="line">  &#125;;</div></pre></td></tr></table></figure></p>
<p><strong>前后台状态获取方式</strong></p>
<ol>
<li>iOS<br>使用iOS的消息通知组件NSNotification，以回调方法的形式注册进去。</li>
<li><p>Android<br>安卓的情况比较复杂，<a href="http://effmx.com/articles/tong-guo-android-fu-zhu-gong-neng-accessibility-service-jian-ce-ren-yi-qian-tai-jie-mian/" target="_blank" rel="external">Android前后台 - EFFMX.COM</a>上对获取安卓前后台状态做了一些可行性方法的介绍。<br>通过一些调研分析，我们可以得出的一些结论是：<br>a.安卓在前后台状态方面没有一个像iOS那样统一的消息组件。<br>b.由于我们是作为一个基础组件SDK提供给App方，在安卓上能操作的能力很有限，比如文章中介绍的Activity回调方式就无法在SDK上做。</p>
<p> 除此之外，在跟我们的客户（Android端 App研发团队）接触后发现，我们的客户已经在App里通过Activity回调实现了前后台状态的通知机制。</p>
<p> 因此在Android上，最终我们选择的方式是：在SDK接入层提供一个通知接口，由App负责将状态变更通过API传递给我们。</p>
</li>
</ol>
<p><strong>安全策略</strong><br>这里的安全策略主要是考虑到，安卓端可能会长时间收不到正确的状态变更通知，这种情况可能是由于上游App出现异常或漏推送状态导致。<br>因此我们做了一个兜底机制，用来防止上游App出现这种情况。</p>
<p>策略设计</p>
<p>首先，策略是基于<a href="http://effmx.com/articles/tong-guo-android-fu-zhu-gong-neng-accessibility-service-jian-ce-ren-yi-qian-tai-jie-mian/" target="_blank" rel="external">Android前后台 - EFFMX.COM</a>里的方法5，主动去扫描进程信息，从而获取当前App状态。<br>这个方法不被官方承认，并且对资源消耗会比较大（涉及循环扫描进程），因此应该尽量少用，这里只使用它用于兜底，正常状态不会被触发。</p>
<p>在java层实现进程扫描方法，可通过主动获取系统锁屏及进程信息方法获取到当前的app是否为前台。在Notifier中内置定时器，默认定时时间为10分钟，即如果超过10分钟未收到状态变更通知则触发保护机制。</p>
<p>计时器到点了以后，将会出现四种可能的情况。</p>
<ul>
<li>如果当前已经处于后台状态了，考虑到这种情况已经不会额外消耗用户的资源了，不做处理了。以下三种都是当前已经在前台的情况下。</li>
<li>发起扫描，如果结果是前台状态，则认为当前确实是在前台，不做处理，重新计时。</li>
<li>发起扫描，如果结果是在后台，则表明端上出现异常，则推送后台状态给用户。</li>
<li>发起扫描，如果扫描进程的过程发生java层可捕获的异常，则当前无法确认准确状态，推送unknown状态给用户。</li>
</ul>
<h3><span id="接口及样例">接口及样例</span></h3><p><strong>注册回调</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> :</span> AppStatusTypeObserver &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Inherit the callback function.</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OnAppStatusTypeChanged</span><span class="params">(AppState type)</span> </span>&#123;</div><div class="line">    <span class="comment">// code in callback</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">MyClass* my_instance = <span class="keyword">new</span> MyClass();</div><div class="line"></div><div class="line"><span class="comment">// Register the instance to notifier.</span></div><div class="line">Notifier::AddAppStatusTypeObserver(my_class);</div></pre></td></tr></table></figure></p>
<p><strong>主动拉取状态</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Get status directly.</span></div><div class="line">AppStatusType status = Notifier::GetAppStatusType();</div><div class="line"></div><div class="line"><span class="comment">// Get the answer that if it is the foreground status.</span></div><div class="line"><span class="keyword">if</span> (Notifier::IsAppInForeground()) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kkrisen.top/20171014/双端前后台状态通知机制实现.html/" data-id="cj8sr6rk0000c1p9koev3kaxj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/20171009/C-静态库符号冲突解决方案.html/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">C++静态库符号冲突解决方案</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/20171014/双端前后台状态通知机制实现.html/">移动端前后台状态通知机制实现</a>
          </li>
        
          <li>
            <a href="/20171009/C-静态库符号冲突解决方案.html/">C++静态库符号冲突解决方案</a>
          </li>
        
          <li>
            <a href="/20171009/项目开源解决方案.html/">项目开源解决方案</a>
          </li>
        
          <li>
            <a href="/20171009/iOS-webview-网络请求代理调研.html/">iOS webview 网络请求代理调研</a>
          </li>
        
          <li>
            <a href="/20171009/iOS版本导致NSURLSession表现不一致问题调研.html/">iOS版本导致NSURLSession表现不一致问题调研</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Krisen Tan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>